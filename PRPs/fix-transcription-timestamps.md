# Fix Transcription Timestamps in JSON Output

## Problem Statement

The transcription.json file generated by the whisper.cpp pipeline has all timestamps set to 0, while the corresponding subtitle.srt file should contain real timestamps. This prevents the AI summarizer from generating time-aware prompts, reducing the quality of summary highlights and timeline generation.

**Current Issue:**
- `transcription.json`: All segments have `"start": 0, "end": 0`
- `subtitle.srt`: Also shows `00:00:00,000 --> 00:00:00,000` 
- **Root Cause**: whisper.cpp CLI parsing is not extracting timestamps correctly
- **Impact**: AI prompts lack timestamp context: `[00:00-00:00] text` instead of `[02:15-04:30] text`

## Context & Existing Architecture

### Current Processing Pipeline

```
YouTube URL → Video Download → Audio Extraction → Whisper.cpp → TranscriptionResult → AI Summarizer
                                                     ↓
                                            transcription.json (❌ timestamps=0)
                                            subtitle.srt (❌ timestamps=0)
```

### Key Files & Implementation

**Transcription Generation:**
- `src/services/transcriber.ts:214-241` - `saveTranscriptionResults()` saves JSON directly from whisper output
- `src/utils/whisper-cli.ts` - CLI wrapper for whisper.cpp (needs investigation)
- `src/types/audio.ts:24-29` - `TranscriptionSegment` interface defines start/end fields

**AI Summarizer (Already Handles Timestamps):**
- `src/services/ai-summarizer.ts:361-373` - `formatTranscript()` properly formats timestamps IF they exist
- `src/services/ai-summarizer.ts:378-382` - `formatTime()` converts seconds to MM:SS format

**Time Utilities:**
- `src/utils/timeline-helper.ts:181-185` - Time formatting utilities
- `src/types/audio.ts:95-102` - SRT time formatting functions

## Implementation Plan

### Task 1: Investigate Whisper CLI Parsing

**Files to examine:**
- `src/utils/whisper-cli.ts` - Check whisper.cpp command arguments and output parsing
- `src/types/audio.ts:107-138` - `parseWhisperOutput()` function implementation

**Key questions:**
1. Are we using the correct whisper.cpp flags for timestamp output (`--output-srt`, `--print-colors`, etc.)?
2. Is the JSON parsing correctly extracting `start`/`end` from whisper output?
3. Is whisper.cpp returning proper timestamp format?

### Task 2: Fix Whisper Output Parsing

**Location:** `src/types/audio.ts:107-138` - `parseWhisperOutput()` function

**Expected Fix Pattern:**
```typescript
// Current (likely broken):
segments: jsonOutput.segments?.map((seg: any) => ({
  start: seg.start || 0,  // ❌ Always fallback to 0
  end: seg.end || 0,
  text: seg.text || '',
}))

// Fixed version:
segments: jsonOutput.segments?.map((seg: any) => ({
  start: Number(seg.start) || 0,  // ✅ Ensure number conversion
  end: Number(seg.end) || 0,
  text: seg.text || '',
  confidence: seg.confidence,
}))
```

**Validation Steps:**
1. Log raw whisper.cpp output to identify actual JSON structure
2. Add error handling for malformed timestamp data
3. Ensure proper number parsing (timestamps might be strings)

### Task 3: Add Fallback SRT Parsing (Optional)

**Purpose:** If whisper JSON output is unreliable, parse SRT file as backup

**Location:** Create `src/utils/srt-parser.ts`

**Implementation:**
```typescript
export function parseSRTToSegments(srtContent: string): TranscriptionSegment[] {
  const segments: TranscriptionSegment[] = [];
  const srtBlocks = srtContent.split('\n\n').filter(block => block.trim());
  
  for (const block of srtBlocks) {
    const lines = block.split('\n');
    if (lines.length >= 3) {
      const timeMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3}) --> (\d{2}):(\d{2}):(\d{2}),(\d{3})/);
      if (timeMatch) {
        const start = parseTimeToSeconds(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
        const end = parseTimeToSeconds(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
        const text = lines.slice(2).join('\n');
        
        segments.push({ start, end, text });
      }
    }
  }
  return segments;
}
```

### Task 4: Create Time Utility Functions

**Location:** `src/utils/time.ts` (new file)

**Implementation:**
```typescript
/**
 * Convert seconds to HH:MM:SS timestamp format
 */
export function secondsToTimestamp(seconds: number): string {
  const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
  const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
  const s = Math.floor(seconds % 60).toString().padStart(2, '0');
  return `${h}:${m}:${s}`;
}

/**
 * Convert HH:MM:SS or MM:SS timestamp to seconds
 */
export function timestampToSeconds(timestamp: string): number {
  const parts = timestamp.split(':').map(Number);
  if (parts.length === 3) {
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
  } else if (parts.length === 2) {
    return parts[0] * 60 + parts[1];
  }
  return 0;
}
```

### Task 5: Update Transcription Service

**Location:** `src/services/transcriber.ts:208-241` - `saveTranscriptionResults()`

**Enhanced Implementation:**
```typescript
private async saveTranscriptionResults(
  transcription: TranscriptionResult,
  outputDir: string
): Promise<void> {
  try {
    // Validate timestamp data before saving
    const validatedTranscription = this.validateTimestamps(transcription);
    
    // Save full transcription as JSON
    const jsonPath = path.join(outputDir, 'transcription.json');
    await fs.writeFile(jsonPath, JSON.stringify(validatedTranscription, null, 2));

    // Generate SRT with proper timestamps
    const srtPath = path.join(outputDir, 'subtitle.srt');
    const srtContent = transcriptionToSRT(validatedTranscription);
    await fs.writeFile(srtPath, srtContent);

    // ... rest of the method
  } catch (error) {
    // ... error handling
  }
}

/**
 * Validate and fix timestamp data
 */
private validateTimestamps(transcription: TranscriptionResult): TranscriptionResult {
  // Check if all timestamps are zero (broken case)
  const hasValidTimestamps = transcription.segments.some(seg => seg.start > 0 || seg.end > 0);
  
  if (!hasValidTimestamps && transcription.duration > 0) {
    console.warn('All timestamps are zero, applying fallback timing');
    // Apply fallback: distribute segments evenly across duration
    const segmentDuration = transcription.duration / transcription.segments.length;
    transcription.segments = transcription.segments.map((seg, index) => ({
      ...seg,
      start: index * segmentDuration,
      end: (index + 1) * segmentDuration,
    }));
  }
  
  return transcription;
}
```

### Task 6: Data Migration Script (Optional)

**Location:** `scripts/fix-json-timestamps.ts` (new file)

**Purpose:** Repair existing tasks with broken timestamps

**Implementation:**
```typescript
#!/usr/bin/env node
import { promises as fs } from 'fs';
import { glob } from 'glob';
import { parseSRTToSegments } from '../src/utils/srt-parser.js';

async function fixExistingTimestamps(dryRun: boolean = true) {
  const srtFiles = await glob('data/*/subtitle.srt');
  
  for (const srtPath of srtFiles) {
    const taskDir = path.dirname(srtPath);
    const jsonPath = path.join(taskDir, 'transcription.json');
    
    if (await fs.access(jsonPath).then(() => true).catch(() => false)) {
      try {
        // Check if JSON has broken timestamps
        const jsonContent = await fs.readFile(jsonPath, 'utf-8');
        const transcription = JSON.parse(jsonContent);
        
        const hasValidTimestamps = transcription.segments.some(seg => seg.start > 0 || seg.end > 0);
        
        if (!hasValidTimestamps) {
          console.log(`Fixing timestamps for: ${taskDir}`);
          
          if (!dryRun) {
            // Read SRT and extract proper timestamps
            const srtContent = await fs.readFile(srtPath, 'utf-8');
            const segments = parseSRTToSegments(srtContent);
            
            // Update transcription with fixed timestamps
            transcription.segments = segments;
            await fs.writeFile(jsonPath, JSON.stringify(transcription, null, 2));
          }
        }
      } catch (error) {
        console.error(`Failed to fix ${taskDir}:`, error);
      }
    }
  }
}

// Usage: npm run fix-timestamps -- --write
const dryRun = !process.argv.includes('--write');
fixExistingTimestamps(dryRun);
```

### Task 7: Update Test Validation

**Location:** `test-prompt.js:127-133`

**Add Timestamp Validation:**
```javascript
// After loading transcription data
console.log('✅ 已加载转录数据');
console.log(`📄 转录文本长度: ${transcription.text.length} 字符`);

// ✅ NEW: Validate timestamps
const hasValidTimestamps = transcription.segments.some(seg => seg.start > 0 || seg.end > 0);
console.log(`⏰ 时间戳状态: ${hasValidTimestamps ? '✅ 有效' : '❌ 全部为0'}`);

if (hasValidTimestamps) {
  const firstSeg = transcription.segments[0];
  const lastSeg = transcription.segments[transcription.segments.length - 1];
  console.log(`⏱️  时间范围: ${firstSeg.start}s - ${lastSeg.end}s`);
}

console.log(`⏱️  视频时长: ${Math.round(transcription.duration / 60)} 分钟\n`);

// Later in the test...
// ✅ NEW: Verify prompt contains timestamps
if (hasValidTimestamps) {
  const hasTimestampMarkers = userPrompt.includes('[0') && userPrompt.includes(':');
  console.log(`🔍 提示词包含时间轴: ${hasTimestampMarkers ? '✅ 是' : '❌ 否'}`);
}
```

## Validation & Testing

### Unit Tests

**Location:** `tests/unit/services/transcriber.test.ts`

```typescript
describe('Timestamp Validation', () => {
  it('should preserve valid timestamps', () => {
    const input = {
      segments: [
        { start: 0, end: 10, text: 'Hello' },
        { start: 10, end: 20, text: 'World' }
      ]
    };
    const result = transcriber.validateTimestamps(input);
    expect(result.segments[0].start).toBe(0);
    expect(result.segments[1].end).toBe(20);
  });

  it('should apply fallback for zero timestamps', () => {
    const input = {
      segments: [
        { start: 0, end: 0, text: 'Hello' },
        { start: 0, end: 0, text: 'World' }
      ],
      duration: 60
    };
    const result = transcriber.validateTimestamps(input);
    expect(result.segments[0].start).toBe(0);
    expect(result.segments[0].end).toBe(30);
    expect(result.segments[1].start).toBe(30);
    expect(result.segments[1].end).toBe(60);
  });
});
```

### Integration Tests

**Location:** `tests/integration/whisper-parsing.test.ts`

```typescript
describe('Whisper Timestamp Parsing', () => {
  it('should extract timestamps from whisper JSON output', async () => {
    const mockWhisperOutput = JSON.stringify({
      segments: [
        { start: 0.0, end: 5.5, text: 'Hello world' },
        { start: 5.5, end: 12.0, text: 'How are you?' }
      ]
    });
    
    const result = parseWhisperOutput(mockWhisperOutput);
    expect(result.segments).toHaveLength(2);
    expect(result.segments[0].start).toBe(0);
    expect(result.segments[0].end).toBe(5.5);
    expect(result.segments[1].start).toBe(5.5);
  });
});
```

### Manual Validation

1. **Run Test Script:** `node test-prompt.js` should show valid timestamps
2. **Check Generated Prompt:** Should contain `[MM:SS-MM:SS]` format instead of `[00:00-00:00]`
3. **Verify AI Output:** Summary highlights should have realistic time ranges

## Backward Compatibility

### Graceful Degradation

- If timestamps are still broken after fix, apply fallback timing
- Maintain existing API interfaces (`TranscriptionSegment`)
- Preserve existing file formats (`transcription.json`, `subtitle.srt`)

### Migration Strategy

1. **Phase 1:** Fix whisper parsing for new transcriptions
2. **Phase 2:** Add fallback validation for edge cases  
3. **Phase 3:** (Optional) Run migration script for existing data

## Expected Outcome

**Before Fix:**
```json
{
  "segments": [
    {"start": 0, "end": 0, "text": "Thank you I'm honored..."}
  ]
}
```

**After Fix:**
```json
{
  "segments": [
    {"start": 0, "end": 45.2, "text": "Thank you I'm honored..."},
    {"start": 45.2, "end": 89.7, "text": "Today I want to tell you three stories..."}
  ]
}
```

**AI Prompt Enhancement:**
```
Before: [00:00-00:00] Thank you I'm honored...
After:  [00:00-00:45] Thank you I'm honored...
        [00:45-01:30] Today I want to tell you three stories...
```

## Risk Assessment

- **Low Risk:** Existing functionality preserved with fallback mechanisms
- **Medium Risk:** Need to verify whisper.cpp command arguments and output format
- **High Value:** Significantly improves AI summary quality with temporal awareness

## Dependencies

- **whisper.cpp**: Ensure proper CLI flags for timestamp output
- **Node.js fs/promises**: File I/O operations  
- **Existing utilities**: Leverage `timeline-helper.ts` formatting functions

## Definition of Done

- [ ] All new transcriptions have valid timestamps (start > 0 for segments after first)
- [ ] `test-prompt.js` shows timestamps are working
- [ ] AI summarizer prompt contains real time markers `[MM:SS-MM:SS]`
- [ ] Unit tests cover timestamp validation logic
- [ ] Integration tests verify whisper parsing
- [ ] Backward compatibility maintained for existing files
- [ ] Optional migration script available for existing data

---

## Score: 8/10

**Confidence Level:** High confidence for one-pass implementation success. Clear problem identification, existing architecture understanding, and comprehensive solution with fallback mechanisms.